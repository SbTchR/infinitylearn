<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mémorisation - Diaporama</title>
    <link rel="stylesheet" href="style.css">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script src="firebase-config.js"></script>
</head>

<body>

    <div id="viewer-container">
        <div class="content-card">
            <img id="slide-image" class="slide-image hidden" src="" alt="Illustration">
            <div id="question-text" class="question-text">Chargement...</div>
            <div id="answer-text" class="answer-text"></div>
        </div>
        <div id="progress-bar" class="progress-bar"></div>
        <div id="countdown-timer"></div>
    </div>

    <script>
        const questionEl = document.getElementById('question-text');
        const answerEl = document.getElementById('answer-text');
        const imageEl = document.getElementById('slide-image');
        const progressBar = document.getElementById('progress-bar');
        const timerEl = document.getElementById('countdown-timer');

        let questions = [];
        let currentIndex = 0;
        let timerInterval;

        // Configuration par défaut (sera écrasée par Firebase)
        let QUESTION_DURATION = 10000;
        let ANSWER_DURATION = 5000;
        let activeListId = null;

        // 1. Écouter la configuration globale
        db.collection("config").doc("global").onSnapshot((doc) => {
            if (doc.exists) {
                const config = doc.data();

                // Mise à jour des timers
                if (config.questionDuration) QUESTION_DURATION = config.questionDuration * 1000;
                if (config.answerDuration) ANSWER_DURATION = config.answerDuration * 1000;

                // Changement de liste active
                if (config.activeListId && config.activeListId !== activeListId) {
                    activeListId = config.activeListId;
                    console.log("Nouvelle liste active détectée:", activeListId);
                    loadQuestions(activeListId);
                }
            }
        });

        function loadQuestions(listId) {
            console.log("Chargement des questions pour la liste:", listId);
            db.collection("questions").where("listId", "==", listId).get().then((querySnapshot) => {
                questions = [];
                querySnapshot.forEach((doc) => {
                    questions.push(doc.data());
                });

                // Tri côté client (order, sinon createdAt)
                questions.sort((a, b) => {
                    if (typeof a.order !== 'undefined' && typeof b.order !== 'undefined') {
                        return a.order - b.order;
                    }
                    const timeA = a.createdAt ? a.createdAt.seconds : 0;
                    const timeB = b.createdAt ? b.createdAt.seconds : 0;
                    return timeB - timeA;
                });

                if (questions.length > 0) {
                    currentIndex = 0; // Reset au début
                    startSlideshow();
                } else {
                    questionEl.textContent = "Aucune question dans cette liste.";
                    answerEl.textContent = "";
                    imageEl.classList.add('hidden');
                }
            }).catch((error) => {
                console.error("Erreur de chargement:", error);
                questionEl.textContent = "Erreur de chargement des données.";
            });
        }

        function startSlideshow() {
            // Nettoyer l'existant si on redémarre
            clearTimeout(window.slideTimeout);
            clearInterval(timerInterval);
            showQuestion();
        }

        function showQuestion() {
            if (questions.length === 0) return;

            const currentItem = questions[currentIndex];

            // Reset UI
            clearInterval(timerInterval);
            timerEl.style.display = 'none';

            // Masquer la réponse INSTANTANÉMENT pour éviter le flash du nouveau texte
            answerEl.style.transition = 'none';
            answerEl.classList.remove('visible');
            answerEl.style.opacity = '0';

            // Mise à jour du texte (invisible pour l'instant)
            answerEl.textContent = currentItem.answer;

            questionEl.textContent = currentItem.question;

            if (currentItem.imageUrl) {
                imageEl.src = currentItem.imageUrl;
                imageEl.classList.remove('hidden');
            } else {
                imageEl.classList.add('hidden');
            }

            // Animation barre de progression pour la question
            runProgressBar(QUESTION_DURATION, () => {
                showAnswer();
            });
        }

        function showAnswer() {
            // Réactiver la transition pour le fade-in
            answerEl.style.transition = 'opacity 0.5s ease-in-out';
            // Force reflow pour que la transition soit prise en compte
            void answerEl.offsetWidth;

            answerEl.classList.add('visible');
            answerEl.style.opacity = '1';

            // Afficher et gérer le timer numérique
            timerEl.style.display = 'block';
            let timeLeft = Math.ceil(ANSWER_DURATION / 1000);
            timerEl.textContent = timeLeft;

            timerInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft > 0) {
                    timerEl.textContent = timeLeft;
                } else {
                    clearInterval(timerInterval);
                }
            }, 1000);

            // Reset barre de progression
            progressBar.style.transition = 'none';
            progressBar.style.width = '0%';

            window.slideTimeout = setTimeout(() => {
                // Passer à la suivante
                currentIndex = (currentIndex + 1) % questions.length;
                showQuestion();
            }, ANSWER_DURATION);
        }

        function runProgressBar(duration, callback) {
            progressBar.style.transition = 'none';
            progressBar.style.width = '0%';

            // Force reflow
            void progressBar.offsetWidth;

            progressBar.style.transition = `width ${duration}ms linear`;
            progressBar.style.width = '100%';

            window.slideTimeout = setTimeout(callback, duration);
        }

        // Auto-refresh toutes les heures (3600000 ms) pour récupérer les nouvelles questions
        setTimeout(() => {
            console.log("Auto-refresh du diaporama...");
            window.location.reload();
        }, 3600000);

    </script>
</body>

</html>